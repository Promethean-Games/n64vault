ion set, creating answer...');
                return pc.createAnswer();
            }).then(function(answer) {
                console.log('[RTC] Answer created, setting local description...');
                return pc.setLocalDescription(answer);
            }).then(function() {
                // Wait for ICE gathering to complete before sending answer
                return new Promise(function(resolve) {
                    if (pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        var checkState = function() {
                            console.log('[RTC] Guest waiting for ICE gathering, state:', pc.iceGatheringState);
                            if (pc.iceGatheringState === 'complete') {
                                pc.removeEventListener('icegatheringstatechange', checkState);
                                resolve();
                            }
                        };
                        pc.addEventListener('icegatheringstatechange', checkState);
                        // Timeout fallback
                        setTimeout(function() {
                            console.log('[RTC] ICE gathering timeout, sending answer anyway');
                            pc.removeEventListener('icegatheringstatechange', checkState);
                            resolve();
                        }, 5000);
                    }
                });
            }).then(function() {
                console.log('[RTC] Guest ICE gathering done, candidates in SDP:', pc.localDescription.sdp.includes('a=candidate'));
                mpSend({
                    type: 'rtc-answer',
                    targetId: hostId,
                    sdp: pc.localDescription
                });
                console.log('[RTC] Sent answer to host');
            }).catch(function(e) {
                console.error('[RTC] Failed to handle offer:', e);
            });
        }
        
        // HOST: Handle answer from guest
        function rtcHandleAnswer(guestId, sdp) {
            console.log('[RTC] Received answer from guest:', guestId);
            var peer = state.mp.peers[guestId];
            if (peer && peer.pc) {
                peer.pc.setRemoteDescription(new RTCSessionDescription(sdp)).catch(function(e) {
                    console.error('[RTC] Failed to set remote description:', e);
                });
            }
        }
        
        // Handle ICE candidate from peer
        function rtcHandleIce(peerId, candidate) {
            var candidateType = 'unknown';
            try {
                if (candidate && candidate.candidate) {
                    var parts = candidate.candidate.split(' ');
                    candidateType = parts.length > 7 ? parts[7] : parts[0];
                }
            } catch (err) {
                console.warn('[RTC] Could not parse received candidate type:', err);
            }
            console.log('[RTC] Received ICE candidate from:', peerId, 'type:', candidateType);
            
            var peer = state.mp.peers[peerId];
            if (peer && peer.pc) {
                peer.pc.addIceCandidate(new RTCIceCandidate(candidate)).then(function() {
                    console.log('[RTC] ICE candidate added successfully, type:', candidateType);
                }).catch(function(e) {
                    console.error('[RTC] Failed to add ICE candidate:', e);
                });
            } else {
                console.warn('[RTC] No peer connection found for:', peerId, 'available peers:', Object.keys(state.mp.peers));
            }
        }
        
        // HOST: Handle input from remote guest
        function rtcHandleRemoteInput(guestId, input) {
            // Find guest's port number
            var guestPlayer = null;
            if (state.mp.room && state.mp.room.players) {
                guestPlayer = state.mp.room.players.find(function(p) { return p.id === guestId; });
            }
            var port = guestPlayer ? guestPlayer.port : 2;
            
            // Inject input into emulator
            // EmulatorJS handles multi-controller via the control ID mapping
            if (input.type === 'button') {
                simulateRemoteButton(port, input.button, input.action);
            } else if (input.type === 'joystick') {
                simulateRemoteJoystick(port, input.x, input.y);
            }
        }
        
        function simulateRemoteButton(port, button, action) {
            // For now, log the input - full implementation needs EmulatorJS multi-controller support
            console.log('[RTC] Remote input P' + port + ':', button, action);
            // EmulatorJS exposes EJS_emulator for direct control in some versions
            // This needs testing with actual EmulatorJS API
        }
        
        function simulateRemoteJoystick(port, x, y) {
            console.log('[RTC] Remote joystick P' + port + ':', x, y);
        }
        
        // GUEST: Send input to host
        function rtcSendInput(input) {
            if (!state.mp.inputsEnabled) return;
            
            // Find host's peer connection
            var hostId = null;
            if (state.mp.room && state.mp.room.players) {
                var host = state.mp.room.players.find(function(p) { return p.role === 'host'; });
                if (host) hostId = host.id;
            }
            
            if (hostId && state.mp.peers[hostId] && state.mp.peers[hostId].dataChannel) {
                var dc = state.mp.peers[hostId].dataChannel;
                if (dc.readyState === 'open') {
                    dc.send(JSON.stringify(input));
                }
            }
        }
        
        // GUEST: Show stream viewer and wait for video - forces UI to stream view from anywhere in app
        function rtcShowGuestStream(gameName, isNewGame) {
            console.log('[RTC] rtcShowGuestStream called for:', gameName, 'isHost:', state.mp.isHost, 'isNewGame:', isNewGame);
            
            // SAFETY: Never hide emulator for host!
            if (state.mp.isHost) {
                console.error('[RTC] BUG: rtcShowGuestStream called for HOST! Ignoring.');
                return;
            }
            
            // If this is a new game (host changed games), clean up existing connections first
            if (isNewGame) {
                console.log('[RTC] New game - cleaning up existing peer connections');
                Object.keys(state.mp.peers).forEach(function(peerId) {
                    var peer = state.mp.peers[peerId];
                    if (peer.pc) {
                        peer.pc.close();
                    }
                });
                state.mp.peers = {};
                
                // Clear existing video
                if (elements.guestVideo) {
                    elements.guestVideo.srcObject = null;
                }
            }
            
            // FORCE UI to stream view regardless of current location
            // 1. Switch main tab to library and ensure library content pane is visible
            state.mainTab = 'library';
            elements.mainTabLibrary.classList.add('active');
            elements.mainTabControls.classList.remove('active');
            elements.mainTabMultiplayer.classList.remove('active');
            elements.mainContentLibrary.classList.add('active');
            elements.mainContentControls.classList.remove('active');
            elements.mainContentMultiplayer.classList.remove('active');
            
            // 2. Hide ALL other library content - upload, games, emulator
            elements.uploadZone.style.display = 'none';
            elements.gameGrid.style.display = 'none';
            elements.emulatorContainer.style.display = 'none';
            
            // 3. Show guest stream container - this is the key view for guests
            elements.guestStreamContainer.classList.add('active');
            
            // 4. Show connecting overlay
            elements.streamOverlay.classList.remove('hidden');
            elements.streamOverlayText.textContent = 'Connecting to host...';
            elements.streamStatusDot.classList.remove('connected');
            elements.streamStatusText.textContent = 'Connecting...';
            
            // Enable input forwarding
            state.mp.inputsEnabled = true;
            
            // 5. Request a fresh offer from the host (in case host already sent offers before we were ready)
            if (isNewGame && state.mp.room) {
                console.log('[RTC] Guest requesting fresh offer from host');
                setTimeout(function() {
                    mpSend({ type: 'request-offer' });
                }, 500);
            }
            
            setStatus('Watching: ' + gameName, 'ready');
            console.log('[RTC] Guest stream view activated, waiting for host offer...');
        }
        
        // GUEST: Show waiting screen when host is changing games - also forces UI to stream view
        function rtcShowWaitingForNewGame() {
            console.log('[RTC] Showing waiting for new game screen');
            
            // SAFETY: Never show for host!
            if (state.mp.isHost) {
                console.error('[RTC] BUG: rtcShowWaitingForNewGame called for HOST! Ignoring.');
                return;
            }
            
            // Clean up existing RTC connection but stay in room
            Object.keys(state.mp.peers).forEach(function(peerId) {
                var peer = state.mp.peers[peerId];
                if (peer.pc) peer.pc.close();
            });
            state.mp.peers = {};
            
            // FORCE UI to stream view regardless of where guest is in the app
            // Explicitly set main tab state and toggle classes
            state.mainTab = 'library';
            elements.mainTabLibrary.classList.add('active');
            elements.mainTabControls.classList.remove('active');
            elements.mainTabMultiplayer.classList.remove('active');
            elements.mainContentLibrary.classList.add('active');
            elements.mainContentControls.classList.remove('active');
            elements.mainContentMultiplayer.classList.remove('active');
            
            // Hide library content
            elements.uploadZone.style.display = 'none';
            elements.gameGrid.style.display = 'none';
            elements.emulatorContainer.style.display = 'none';
            
            // Show guest stream container
            elements.guestStreamContainer.classList.add('active');
            
            // Update the stream overlay to show waiting message
            elements.streamOverlay.classList.remove('hidden');
            elements.streamOverlayText.textContent = 'Host is loading a new game...';
            elements.streamStatusDot.classList.remove('connected');
            elements.streamStatusText.textContent = 'Waiting for new game...';
            
            // Clear video but keep container visible
            if (elements.guestVideo) {
                elements.guestVideo.srcObject = null;
            }
            
            setStatus('Waiting for host to load game...', 'loading');
        }
        
        // ===== Init =====
        function init() {
            console.log('%c[Netcade] Version: ' + window.NETCADE_CONFIG.version, 'color: #E43F5A; font-weight: bold; font-size: 14px;');
            initElements();
            
            state.isMobile = isMobileDevice();
            if (state.isMobile) {
                elements.tabMobile.style.display = 'flex';
                switchMode('mobile');
            }
            
            render();
            bindEvents();
            detectGamepads();
            loadGames();
            
            // Wire up buttons to return to library
            elements.btnNewGame.addEventListener('click', function() {
                showLibrary();
            });
            elements.btnBackToLibrary.addEventListener('click', function() {
                showLibrary();
            });
            
            // Guest stream back button
            if (elements.btnBackFromStream) {
                elements.btnBackFromStream.addEventListener('click', function() {
                    rtcCleanup();
                    elements.guestStreamContainer.classList.remove('active');
                    showLibrary();
                    mpLeaveRoom();
                });
            }
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    })();
    
    // Clear cache button handler
    document.getElementById('clearCacheBtn').addEventListener('click', function() {
        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            var messageChannel = new MessageChannel();
            messageChannel.port1.onmessage = function() {
                caches.keys().then(function(names) {
                    return Promise.all(names.map(function(name) { return caches.delete(name); }));
                }).then(function() {
                    window.location.reload(true);
                });
            };
            navigator.serviceWorker.controller.postMessage({ type: 'CLEAR_CACHE' }, [messageChannel.port2]);
        } else {
            caches.keys().then(function(names) {
                return Promise.all(names.map(function(name) { return caches.delete(name); }));
            }).then(function() {
                window.location.reload(true);
            });
        }
    });
    
    // Register Service Worker for PWA
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
            navigator.serviceWorker.register('./sw.js')
                .then(function(registration) {
                    console.log('SW registered:', registration.scope);
                })
                .catch(function(error) {
                    console.log('SW registration failed:', error);
                });
        });
    }
    </script>
    
    <!-- Cookie Consent Banner -->
    <div class="cookie-banner hidden" id="cookieBanner">
        <div class="cookie-text">
            We use cookies for analytics and to show personalized ads. By using this site, you agree to our 
            <a href="privacy.html">Privacy Policy</a>. You can opt out of personalized ads at 
            <a href="https://www.google.com/settings/ads" target="_blank" rel="noopener">Google Ads Settings</a>.
        </div>
        <div class="cookie-buttons">
            <button class="cookie-btn cookie-btn-decline" id="cookieDecline" data-testid="button-cookie-decline">Decline</button>
            <button class="cookie-btn cookie-btn-accept" id="cookieAccept" data-testid="button-cookie-accept">Accept</button>
        </div>
    </div>
    
    <!-- Footer Links -->
    <div class="footer-links">
        <a href="privacy.html">Privacy Policy</a>
    </div>
    
    <script>
    (function() {
        var banner = document.getElementById('cookieBanner');
        var acceptBtn = document.getElementById('cookieAccept');
        var declineBtn = document.getElementById('cookieDecline');
        
        // Check if consent was already given
        var consent = localStorage.getItem('netcade_cookie_consent');
        
        if (!consent) {
            // Show banner if no consent decision made
            banner.classList.remove('hidden');
        }
        
        acceptBtn.addEventListener('click', function() {
            localStorage.setItem('netcade_cookie_consent', 'accepted');
            banner.classList.add('hidden');
            // Here you would initialize AdSense and analytics
            console.log('[Netcade] Cookie consent accepted');
        });
        
        declineBtn.addEventListener('click', function() {
            localStorage.setItem('netcade_cookie_consent', 'declined');
            banner.classList.add('hidden');
            console.log('[Netcade] Cookie consent declined - personalized ads disabled');
        });
    })();
    </script>
</body>
</html>
